# 第五次实验
## 22371437 张智威

### Q1
```
alter table bdcopy1 add index Q1(v)
```
#### 等值查询语句为：
```
select * from bdcopy1(2)
where v = 1001
```
<hr>

##### 从bdcopy1表中查询
<div align=center><img src="image-5.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image.png"></div>

#### 范围查询语句为：
```
select * from bdcopy1(2) where v>10000
```
##### 从bdcopy1表中查询
<div align=center><img src="image-4.png"></div>

#### 从bdcopy2表中查询
<div align=center><img src="image-3.png"></div>

<br>
<font face='楷体' size = 4>&ensp; &ensp;&ensp;对于B+树索引，无论是等值查找还是范围查找，其速度均显著快于不使用索引，这是由于对于两种查找方式，不使用索引都需要扫描表中每一行数据来逐一判断是否满足要求，而使用了B+树索引只需要根据树的每一层节点值的划分情况，来根据需要寻找所满足的叶子节点，不需要对每一行数据都进行查询，节省了大量存储I/O次数，从而节约了大量时间。</font>

### Q2
#### 等值查询语句为：
```
select * from bdcopy1(3)
where v = 1001
```
##### 从bdcopy1表中查询
<div align=center><img src="image-1.png"></div>

##### 从bdcopy3表中查询
<div align=center><img src="image-2.png"></div>

##### 从bdcopy4表中查询
<div align=center><img src="image-6.png"></div>

##### 从bdcopy5表中查询
<div align=center><img src="image-7.png"></div>

<br>
<font face='楷体' size = 4>&ensp; &ensp;&ensp;bdcopy1查询时间与bdcopy3中近乎相等，这是由于MySql默认的InnoDB引擎不支持hash索引，此处实际建立了B+索引，两个表的索引相同。而bdcopy4查询时间显著短于bdcopy5，这是由于在相同数据的情况下，由于有Hash索引的存在，只需要计算哈希值然后在Hash桶中进行判断即可，不需要所有数据全部查询，大大节省了时间。</font>

### Q3
#### 等值查询语句为：
```
select * from bdcopy1(23)
where v = 399998
```
##### 从bdcopy1表中查询
<div align=center><img src="image-8.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image-9.png"></div>

#### 范围查询语句为：
```
select * from bdcopy1(2)
where bid between 10000 and 120000
```
##### 从bdcopy1表中查询
<div align=center><img src="image-10.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image-11.png"></div>

<br>
<font face='楷体' size = 4>&ensp; &ensp;&ensp;等值查找时，聚簇索引和B+树索引时间差距不大，而在进行范围查找时，由于聚簇索引数据按照物理顺序排放，在聚簇索引的列上进行范围查找时只需要查找少数几个页，使得聚簇索引速度显著大于B+树索引。</font>

### Q4
#### Test1
```
select * from bdcopy1(2)
where v > 10001 and s = 7
```
##### 从bdcopy1表中查询
<div align=center><img src="image-13.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image-14.png"></div>

#### Test2
```
select * from bdcopy1(2)
where v > 10001
```
##### 从bdcopy1表中查询
<div align=center><img src="image-16.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image-15.png"></div>

#### Test3
```
select * from bdcopy1(2)
where s = 7
```
##### 从bdcopy1表中查询
<div align=center><img src="image-19.png"></div>

##### 从bdcopy2表中查询
<div align=center><img src="image-18.png"></div>

<br>
<font face='楷体' size = 4>&ensp; &ensp;&ensp;Test1中，对两列同时进行条件判断查找，联合索引由于最左前缀的优势，查询速度较快。Test2中，仅对联合索引中最左列进行查找，联合索引等同于一个B+树索引，两张表查询速度等同，Test3中对非联合索引最左列进行查找，两个表相当于在此列中均未设立索引，所以查询速度相当。</font>

### Q5
#### Test1
```
Explain select * from bdcopy1 where bid/2=30000
```
<div align=center><img src="image-20.png"></div>
<div align=center><img src="image-21.png"></div>

#### Test2
```
Explain select * from bdcopy1 where bid=30000*2
```
<div align=center><img src="image-23.png"></div>
<div align=center><img src="image-22.png"></div>

<font face='楷体' size = 4>&ensp; &ensp;&ensp;Test1中，查询`type`为`all`，即实际上全部数据都查询了一次，Test2中，查询`type`为`ref`，表示使用了索引进行扫描。原因是第一种写法需要对每一行数据的bid进行除以2的操作再与30000比较，因此无法使用B+树索引，而第二个写法就相当于与60000比较，可以使用B+树索引，因此第二个的时间也比第一个的时间短。